# @contactlab/appy

[![Build Status](https://clab-dev.visualstudio.com/OSS/_apis/build/status/contactlab.appy?branchName=master)](https://clab-dev.visualstudio.com/OSS/_build/latest?definitionId=32&branchName=master)

A functional wrapper around Fetch API

## Install

```sh
$ npm install @contactlab/appy

# --- or ---

$ yarn add @contactlab/appy
```

## Motivation

`appy` tries to offer a better model for fetching resources, using the standard global `fetch()` function as a "backbone" and some principles from Functional Programming paradigm.

The model is built around the concepts of:

- a function with some configurable options (`Reader`)
- that runs asynchronous operations (`Task`)
- which can fail for some reason (`Either`)

In order to achieve this, `appy` intensely uses:

- [Typescript](https://www.typescriptlang.org) >= v3.2.2
- [`fp-ts`](https://github.com/gcanti/fp-ts)

## API

`appy` exposes a simple core API that can be extended with ["combinators"](#combinators).

It encodes through the `Req<A>` type a resource's request, or rather, an async operation that can fail or return a `Resp<A>`.

The request is expressed in terms of `ReaderTaskEither` - a function that takes a `ReqInput` as parameter and returns a `TaskEither` - for better composability: we can act on both side of operation (input and output) with the tools provided by `fp-ts`.

```ts
interface Req<A> extends RTE.ReaderTaskEither<ReqInput, Err, Resp<A>> {}
```

`ReqInput` encodes the `fetch()` parameters: a single [`RequestInfo`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters) (simple string or [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object) or a tuple of `RequestInfo` and [`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters) (the object containing request's options, that it's optional in the original `fetch()` API).

```ts
type ReqInput = RequestInfo | RequestInfoInit;

// Just an alias for a tuple of `RequesInfo` and `RequestInit` (a.k.a. the `fetch()` parameters)
type RequestInfoInit = [RequestInfo, RequestInit];
```

`Resp<A>` is an object that carries the original `Response` from a `fetch()` call and the actual retrieved `data` (of type `A`).

```ts
interface Resp<A> {
  response: Response;
  data: A;
}
```

`Err` encodes (as tagged union) the two kind of error that can be generated by `Req`: a `RequestError` or a `ResponseError`.

`RequestError` represents a request error. It carries the generated `Error` and the input of the request (`RequestInfoInit` tuple).

`ResponseError` represents a response error. It carriess the generated `Error` and the original `Response` object.

```ts
type Err = RequestError | ResponseError;

interface RequestError {
  type: 'RequestError';
  error: Error;
  input: RequestInfoInit;
}

interface ResponseError {
  type: 'ResponseError';
  error: Error;
  response: Response;
}
```

## Examples

```ts
import {get} from '@contactlab/appy';
import {fold} from 'fp-ts/lib/Either';

const posts = get('http://jsonplaceholder.typicode.com/posts');

posts().then(
  fold(
    err => console.error(err),
    data => console.log(data)
  )
);
```

You can find other examples [here](examples).

## Combinators

In order to make extending the library functionalities easier, any other feature should then be expressed as simple combinator `Req<A> => Req<A>`.

So, for example, decoding the response body as JSON:

```ts
import {get} from '@contactlab/appy';
import {withDecoder, Decoder} from '@contactlab/appy/combinators/decoder';
import {pipe} from 'fp-ts/lib/pipeable';

interface Post {
  id: number;
  userId: number;
  title: string;
  body: string;
}

declare const decoder: Decoder<Post>;

const getPost = pipe(withDecoder(decoder), get);

const singlePost = getPost('http://jsonplaceholder.typicode.com/posts/1');
```

or adding headers to the request:

```ts
import {get} from '@contactlab/appy';
import {withHeaders} from '@contactlab/appy/combinators/headers';

const asJson = withHeaders({'Content-Type': 'application/json'})(get);

const posts = asJson('http://jsonplaceholder.typicode.com/posts');
```

or setting request's body (for `POST`s or `PUT`s):

```ts
import {post} from '@contactlab/appy';
import {withBody} from '@contactlab/appy/combinators/body';
import {pipe} from 'fp-ts/lib/pipeable';

const send = pipe(
  withBody({userId: 1234, title: 'My post title', body: 'My post body'}),
  post
);

const addPost = send('http://jsonplaceholder.typicode.com/posts');
```

## About `fetch()` compatibility

The Fetch API is available only on "modern" browsers: if you need to support legacy browsers (e.g. **Internet Explorer 11** or older) or you want to use it in a Nodejs script we recommend you the excellent [`cross-fetch`](https://www.npmjs.com/package/cross-fetch) package.

## Contributing

Opening issues is always welcome.

Then, fork the repository or create a new branch, write your code and send a pull request.

This project uses [Prettier](https://prettier.io/) (automatically applied as pre-commit hook), [ESLint](https://eslint.org/) (with [TypeScript integration](https://github.com/typescript-eslint/typescript-eslint)) and [Jest](https://facebook.github.io/jest/en/).

## License

Released under the [Apache 2.0](LICENSE) license.
