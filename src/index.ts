/**
 * appy - A functional wrapper around Fetch API.
 *
 * @since 3.0.0
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API|Fetch Api}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch|Global fetch}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch|Using fetch}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Request|Request}
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Response|Response}
 * @see {@link https://gcanti.github.io/fp-ts/ReaderTaskEither.html|ReaderTaskEither}
 */

import * as E from 'fp-ts/lib/Either';
import {local, ReaderTaskEither} from 'fp-ts/lib/ReaderTaskEither';
import * as TU from 'fp-ts/lib/Tuple';
import {pipe} from 'fp-ts/lib/pipeable';

/**
 * `Req<A>` encodes a resource's request, or rather, an async operation that can fail or return a `Resp<A>`.
 *
 * The request is expressed in terms of `ReaderTaskEither` - a function that takes a `ReqInput` as parameter and returns a `TaskEither` - for better composability: we can act on both side of operation (input and output) with the tools provided by `fp-ts`.
 *
 * @category Request
 * @since 3.0.0
 */
export interface Req<A> extends ReaderTaskEither<ReqInput, Err, Resp<A>> {}

/**
 * `ReqInput` encodes the `fetch()` parameters: a single [`RequestInfo`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters) (simple string or [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object) or a tuple of `RequestInfo` and [`RequestInit`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters) (the object containing request's options, that it's optional in the original `fetch()` API).
 *
 * @category Request
 * @since 3.0.0
 */
export type ReqInput = RequestInfo | RequestInfoInit;
/**
 * An alias for a tuple of `RequesInfo` and `RequestInit` (a.k.a. the `fetch()` parameters).
 *
 * @category Request
 * @since 3.0.0
 */
export type RequestInfoInit = [RequestInfo, RequestInit];

/**
 * `Resp<A>` is an object that carries the original `Response` from a `fetch()` call and the actual retrieved `data` (of type `A`).
 *
 * @category Response
 * @since 3.0.0
 */
export interface Resp<A> {
  response: Response;
  data: A;
}

/**
 * `Err` encodes the two kind of error that can be generated by `Req`: a `RequestError` or a `ResponseError`.
 *
 * @category Error
 * @since 3.0.0
 */
export type Err = RequestError | ResponseError;

/**
 * `RequestError` represents a request error. It carries the generated `Error` and the input of the request (`RequestInfoInit` tuple).
 *
 * @category Error
 * @since 3.0.0
 */
export interface RequestError {
  type: 'RequestError';
  error: Error;
  input: RequestInfoInit;
}

/**
 * `ResponseError` represents a response error. It carriess the generated `Error` and the original `Response` object.
 *
 * @category Error
 * @since 3.0.0
 */
export interface ResponseError {
  type: 'ResponseError';
  error: Error;
  response: Response;
}

/**
 * Makes a request using `fetch()` under the hood.
 *
 * The `data` in the returned `Resp` object is a `string` because the response's body can **always** be converted to text without error (via [`text()`](https://developer.mozilla.org/en-US/docs/Web/API/Body/text) method).
 *
 * Example:
 * ```ts
 * import {request} from '@contactlab/appy';
 * import {fold} from 'fp-ts/lib/Either';
 *
 * // Default method is GET like original `fetch()`
 * const users = request('https://reqres.in/api/users');
 *
 * users().then(
 *   fold(
 *     err => console.error(err),
 *     data => console.log(data)
 *   )
 * );
 * ```
 *
 * @category creators
 * @since 3.0.0
 */
export const request: Req<string> = input => () => {
  const reqInput = normalizeReqInput(input);

  return fetch(...reqInput)
    .then(
      async response => {
        const data = await response.text();

        return E.right({response, data});
      },
      e => {
        throw toRequestError(e, reqInput);
      }
    )
    .catch(e => E.left(e));
};

/**
 * Makes a request with the `method` set to `GET`.
 *
 * @category creators
 * @since 3.0.0
 */
export const get: Req<string> = pipe(request, local(setMethod('GET')));

/**
 * Makes a request with the `method` set to `POST`.
 *
 * @category creators
 * @since 3.0.0
 */
export const post: Req<string> = pipe(request, local(setMethod('POST')));

/**
 * Makes a request with the `method` set to `PUT`.
 *
 * @category creators
 * @since 3.0.0
 */
export const put: Req<string> = pipe(request, local(setMethod('PUT')));

/**
 * Makes a request with the `method` set to `PATCH`.
 *
 * @category creators
 * @since 3.0.0
 */
export const patch: Req<string> = pipe(request, local(setMethod('PATCH')));

/**
 * Makes a request with the `method` set to `DELETE`.
 *
 * @category creators
 * @since 3.0.0
 */
export const del: Req<string> = pipe(request, local(setMethod('DELETE')));

/**
 * Creates a `RequestError` object.
 *
 * @category Error
 * @since 3.0.0
 */
export function toRequestError(
  error: Error,
  input: RequestInfoInit
): RequestError {
  return {type: 'RequestError', error, input};
}

/**
 * Creates a `ResponseError` object.
 *
 * @category Error
 * @since 3.0.0
 */
export function toResponseError(
  error: Error,
  response: Response
): ResponseError {
  return {type: 'ResponseError', response, error};
}

/**
 * Normalizes the input of a `Req` to a `RequestInfoInit` tuple even when only a single `RequestInfo` is provided.
 *
 * @category Request
 * @since 3.0.0
 */
export function normalizeReqInput(input: ReqInput): RequestInfoInit {
  return Array.isArray(input) ? input : [input, {}];
}

function setMethod(method: string): (input: ReqInput) => RequestInfoInit {
  return input =>
    pipe(
      normalizeReqInput(input),
      TU.mapLeft(init => ({...init, method}))
    );
}
